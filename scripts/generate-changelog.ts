import fs from 'node:fs';
import path from 'node:path';

const CHANGELOG_PATH = path.join(process.cwd(), 'docs/agent-context/changelog.md');
const OUTPUT_PATH = path.join(process.cwd(), 'src/lib/data/changelog.ts');

interface ChangelogEntry {
	version: string;
	date: string;
	title: string;
	summary: string;
	features: { text: string; level: number }[];
	type: 'major' | 'minor' | 'patch';
}

function parseChangelog(content: string): ChangelogEntry[] {
	const entries: ChangelogEntry[] = [];

	// Split content by "## Phase" to handle sections
	const sections = content.split(/^## Phase /m).slice(1); // Skip preamble

	for (const section of sections) {
		// Re-add "Phase " to make regex matching easier or just parse the raw string
		const lines = section.trim().split('\n');
		const titleLine = lines[0];

		// Parse Title: "1: Foundation & Research (Completed)"
		const titleMatch = titleLine.match(/^([\d.]+)(?: Polish)?: (.+) \((.+)\)$/);
		if (!titleMatch) continue;

		const [, version, title] = titleMatch;

		// Find Date
		const dateLine = lines.find((l) => l.startsWith('**Date:**'));
		const date = dateLine ? dateLine.replace('**Date:**', '').trim() : 'Unknown';

		// Find Summary
		const summaryStartIndex = lines.findIndex((l) => l.startsWith('**Summary:**'));
		let summary = '';
		if (summaryStartIndex !== -1) {
			let i = summaryStartIndex + 1;
			while (i < lines.length && !lines[i].startsWith('**Key Deliverables:**')) {
				if (lines[i].trim()) {
					summary += lines[i].trim() + ' ';
				}
				i++;
			}
		}
		summary = summary.trim();

		// Find Deliverables (Features)
		const deliverablesStartIndex = lines.findIndex((l) => l.startsWith('**Key Deliverables:**'));
		const features: { text: string; level: number }[] = [];
		if (deliverablesStartIndex !== -1) {
			for (let i = deliverablesStartIndex + 1; i < lines.length; i++) {
				const line = lines[i];
				const trimmedLine = line.trim();
				if (trimmedLine.startsWith('-')) {
					// Calculate indentation level
					const match = line.match(/^(\s*)-/);
					const indent = match ? match[1].length : 0;
					const level = Math.floor(indent / 2); // Assuming 2 spaces per level

					// Clean up markdown links and code blocks for cleaner UI text
					const cleanLine = trimmedLine.substring(1).trim();
					features.push({ text: cleanLine, level });
				}
			}
		}

		// Determine type based on version/title
		// This is a heuristic. "Polish" or ".5" usually means patch/minor.
		let type: 'major' | 'minor' | 'patch' = 'major';
		if (version.includes('.') || titleLine.toLowerCase().includes('polish')) {
			type = 'patch';
		}

		entries.push({
			version: `Phase ${version}`,
			date,
			title,
			summary,
			features,
			type
		});
	}

	// Sort by date descending (or phase number descending)
	// Assuming the file is chronological, we reverse it to show newest first
	return entries.reverse();
}

function generateFile(entries: ChangelogEntry[]) {
	const content = `// This file is auto-generated by scripts/generate-changelog.ts
// Do not edit manually.

export interface ChangelogEntry {
	version: string;
	date: string;
	title: string;
	summary: string;
	features: { text: string; level: number }[];
	type: 'major' | 'minor' | 'patch';
}

export const CHANGELOG: ChangelogEntry[] = ${JSON.stringify(entries, null, '\t')};
`;

	fs.writeFileSync(OUTPUT_PATH, content);
	console.log(`Changelog generated with ${entries.length} entries at ${OUTPUT_PATH}`);
}

try {
	const content = fs.readFileSync(CHANGELOG_PATH, 'utf-8');
	const entries = parseChangelog(content);
	generateFile(entries);
} catch (error) {
	console.error('Failed to generate changelog:', error);
	process.exit(1);
}
